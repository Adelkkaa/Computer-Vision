### Теоретическая часть: как работает алгоритм оптического потока Лукаса-Канаде

Алгоритм Лукаса-Канаде — это метод вычисления оптического потока, который используется для определения движения объектов между двумя последовательными кадрами видео. Основная идея заключается в том, что интенсивность (яркость) точки на изображении не изменяется при её перемещении. Это предположение называется **постоянством интенсивности**.

#### Основные шаги алгоритма:
1. **Предположение о постоянстве интенсивности**:
   - Если точка \((x, y)\) на первом кадре переместилась на \((x + dx, y + dy)\) на втором кадре, то интенсивность в этих точках должна быть одинаковой:
     \[
     I(x, y, t) = I(x + dx, y + dy, t + 1)
     \]
   - Это уравнение называется **уравнением оптического потока**.

2. **Линеаризация уравнения**:
   - Используя разложение в ряд Тейлора, уравнение оптического потока можно линеаризовать:
     \[
     I_x \cdot dx + I_y \cdot dy + I_t = 0
     \]
   - Здесь \(I_x\), \(I_y\) — частные производные по координатам \(x\) и \(y\), а \(I_t\) — производная по времени.

3. **Решение системы уравнений**:
   - Для решения уравнения оптического потока используется метод наименьших квадратов (МНК). Предполагается, что в небольшой окрестности точки все пиксели движутся одинаково. Это позволяет построить систему уравнений и решить её для нахождения \((dx, dy)\).

4. **Итеративное уточнение**:
   - Для повышения точности используется пирамида изображений (Gaussian pyramid). Оптический поток сначала вычисляется на уменьшенных изображениях, а затем уточняется на более крупных масштабах.

5. **Реализация в OpenCV**:
   - В OpenCV для вычисления оптического потока используется функция `cv2.calcOpticalFlowPyrLK()`, которая реализует метод Лукаса-Канаде с использованием пирамиды изображений.

---

### Построчное объяснение кода

```python
import cv2
import numpy as np
```
- Импортируются библиотеки OpenCV (`cv2`) для работы с изображениями и видео, а также NumPy (`numpy`) для работы с массивами.

```python
cap = cv2.VideoCapture('istockphoto-1369953926-640_adpp_is - Trim.mp4')
```
- Создается объект `VideoCapture`, который открывает видеофайл для чтения. В данном случае используется видеофайл `'istockphoto-1369953926-640_adpp_is - Trim.mp4'`.

```python
points_to_track = []
```
- Создается пустой список `points_to_track`, в который будут добавляться координаты точек, выбранных пользователем для отслеживания.

```python
def select_point(event, x, y, flags, param):
    global points_to_track
    if event == cv2.EVENT_LBUTTONDOWN:
        points_to_track.append((x, y))
        print(f'Точка добавлена: {(x, y)}')
```
- Определяется функция `select_point`, которая будет вызываться при клике мыши. Если происходит левый клик (`cv2.EVENT_LBUTTONDOWN`), координаты точки добавляются в список `points_to_track`.

```python
cv2.namedWindow('Optical Flow Tracking')
cv2.setMouseCallback('Optical Flow Tracking', select_point)
```
- Создается окно с именем `'Optical Flow Tracking'`, и на него назначается функция обработки кликов мыши `select_point`.

```python
mask = None
```
- Создается переменная `mask`, которая будет использоваться для отрисовки линий движения точек. Изначально она равна `None`.

```python
lk_params = dict(winSize=(10, 10), maxLevel=2, criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03))
```
- Задаются параметры для функции `cv2.calcOpticalFlowPyrLK()`:
  - `winSize=(10, 10)` — размер окна, в котором вычисляется оптический поток.
  - `maxLevel=2` — количество уровней в пирамиде изображений.
  - `criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03)` — критерии остановки итеративного процесса (максимум 10 итераций или точность 0.03).

```python
while True:
    ret, frame = cap.read()
    if not ret:
        break
```
- Начинается основной цикл обработки видео. На каждом шаге считывается кадр из видео. Если кадр не удалось прочитать (`ret == False`), цикл прерывается.

```python
    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
```
- Кадр преобразуется в оттенки серого, так как оптический поток вычисляется для одноканального изображения.

```python
    if mask is None:
        mask = np.zeros_like(frame)
```
- Если маска еще не создана, она инициализируется как черное изображение того же размера, что и кадр.

```python
    if len(points_to_track) > 0:
        p0 = np.array(points_to_track, dtype=np.float32).reshape(-1, 1, 2)
```
- Если список точек для отслеживания не пуст, он преобразуется в массив NumPy с типом данных `float32` и формой `(n, 1, 2)`, где `n` — количество точек.

```python
        if 'old_gray' in locals():
            p1, st, err = cv2.calcOpticalFlowPyrLK(old_gray, frame_gray, p0, None, **lk_params)
```
- Если переменная `old_gray` существует (то есть это не первый кадр), вычисляется оптический поток с помощью функции `cv2.calcOpticalFlowPyrLK()`. Результат:
  - `p1` — новые координаты точек.
  - `st` — статус (1, если точка найдена, 0 — если нет).
  - `err` — ошибка для каждой точки.

```python
            good_new = p1[st == 1]
            good_old = p0[st == 1]
```
- Отбираются только те точки, для которых оптический поток был успешно вычислен (`st == 1`).

```python
            for i, (new, old) in enumerate(zip(good_new, good_old)):
                a, b = new.ravel()
                c, d = old.ravel()
                mask = cv2.line(mask, (int(a), int(b)), (int(c), int(d)), (255, 0, 0), 2)
                frame = cv2.circle(frame, (int(a), int(b)), 5, (0, 0, 0), -1)
```
- Для каждой пары точек (старой и новой) рисуется линия на маске (синего цвета) и круг на текущем кадре (черного цвета).

```python
            points_to_track = good_new.reshape(-1, 2).tolist()
```
- Обновляются точки для отслеживания на следующий кадр.

```python
    img = cv2.add(frame, mask)
```
- Маска с линиями накладывается на текущий кадр.

```python
    cv2.imshow('Optical Flow Tracking', img)
```
- Результирующее изображение отображается в окне.

```python
    old_gray = frame_gray.copy()
```
- Текущий кадр сохраняется как `old_gray` для использования на следующем шаге.

```python
    if cv2.waitKey(30) & 0xFF == 27:
        break
```
- Если нажата клавиша ESC (код 27), цикл прерывается.

```python
cap.release()
cv2.destroyAllWindows()
```
- Видео закрывается, и все окна уничтожаются.

---

### Итог
Код реализует слежение за точками на видео с использованием метода оптического потока Лукаса-Канаде. Пользователь может выбирать точки для отслеживания, а программа будет рисовать их траектории на кадре. Основные этапы:
1. Выбор точек для отслеживания.
2. Вычисление оптического потока между кадрами.
3. Отрисовка траекторий движения точек.
4. Отображение результата в реальном времени.