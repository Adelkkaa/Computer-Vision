
## **Метод усреднения фона: теория, примеры и реализация**

---

### **1. Основная идея**
Метод усреднения фона используется для выделения объектов переднего плана в видеопоследовательности. Он основан на предположении, что фон изменяется медленно, а объекты переднего плана появляются и исчезают быстро. Основные шаги:
1. Построение модели фона (среднее значение и стандартное отклонение).
2. Сравнение текущего кадра с моделью фона.
3. Выделение объектов переднего плана как отклонений от фона.

---

### **2. Математическая основа**

#### **2.1. Среднее значение фона**
Среднее значение фона для каждого пикселя вычисляется по формуле скользящего среднего:
\[
\text{background\_avg} = (1 - \alpha) \cdot \text{background\_avg} + \alpha \cdot \text{frame}
\]
где:
- `background_avg` — текущее среднее значение фона.
- `frame` — значение пикселя в текущем кадре.
- `alpha` — скорость обновления фона (обычно от 0.01 до 0.1).

#### **2.2. Стандартное отклонение фона**
Стандартное отклонение используется для оценки вариативности фона. Оно вычисляется по формуле:
\[
\text{background\_std} = (1 - \alpha) \cdot \text{background\_std} + \alpha \cdot (\text{frame} - \text{background\_avg})^2
\]
где:
- `background_std` — текущее значение стандартного отклонения.
- `(frame - background_avg)^2` — квадрат разницы между текущим кадром и средним значением фона.

Стандартное отклонение (`std`) извлекается как квадратный корень из `background_std`:
\[
\text{std} = \sqrt{\text{background\_std}}
\]

#### **2.3. Пороговая обработка**
Для выделения объектов переднего плана используется пороговая обработка. Если разница между текущим кадром и фоном превышает порог, пиксель считается объектом переднего плана:
\[
\text{fg\_mask} = \begin{cases}
255, & \text{если } |\text{frame} - \text{background\_avg}| > k \cdot \text{std} \\
0, & \text{иначе}
\end{cases}
\]
где:
- `k` — коэффициент, определяющий чувствительность метода (обычно 2 или 3).

---

### **3. Пошаговый пример работы алгоритма**

Рассмотрим пример с одним пикселем для простоты. Пусть у нас есть видеопоследовательность из 5 кадров:

| Кадр | Значение пикселя |
|------|------------------|
| 1    | 100              |
| 2    | 102              |
| 3    | 101              |
| 4    | 105              |
| 5    | 110              |

#### **Шаг 1: Инициализация**
- `background_avg` инициализируется первым кадром.
- `background_std` инициализируется нулями.

```python
background_avg = gray_frame.astype("float")
background_std = np.zeros_like(gray_frame, dtype="float")
```

| Кадр | Значение пикселя | Фон (background_avg) | Фон (background_std) |
|------|------------------|----------------------|----------------------|
| 1    | 100              | 100                  | 0                    |

---

#### **Шаг 2: Обновление модели фона**
- Среднее значение и стандартное отклонение обновляются для каждого кадра.

```python
cv2.accumulateWeighted(gray_frame, background_avg, alpha)
cv2.accumulateWeighted((gray_frame - background_avg) ** 2, background_std, alpha)
```

| Кадр | Значение пикселя | Фон (background_avg) | Разница | Квадрат разницы | Фон (background_std) | Стандартное отклонение (std) |
|------|------------------|----------------------|---------|------------------|----------------------|------------------------------|
| 1    | 100              | 100                  | 0       | 0                | 0                    | 0                            |
| 2    | 102              | 100.2                | 1.8     | 3.24             | 0.324                | 0.569                        |
| 3    | 101              | 100.28               | 0.72    | 0.5184           | 0.318                | 0.564                        |
| 4    | 105              | 100.75               | 4.25    | 18.0625          | 2.124                | 1.457                        |
| 5    | 110              | 101.68               | 8.32    | 69.2224          | 8.034                | 2.834                        |

---

#### **Шаг 3: Вычисление разницы**
- Абсолютная разница между текущим кадром и фоном.

```python
diff = cv2.absdiff(gray_frame, background_avg.astype("uint8"))
```

| Кадр | Значение пикселя | Фон (background_avg) | Разница |
|------|------------------|----------------------|---------|
| 1    | 100              | 100                  | 0       |
| 2    | 102              | 100.2                | 1.8     |
| 3    | 101              | 100.28               | 0.72    |
| 4    | 105              | 100.75               | 4.25    |
| 5    | 110              | 101.68               | 8.32    |

---

#### **Шаг 4: Пороговая обработка**
- Используется стандартное отклонение для определения порога.

```python
std = cv2.sqrt(background_std)
mean_std = np.mean(std)
_, fg_mask = cv2.threshold(diff, 2 * mean_std, 255, cv2.THRESH_BINARY)
```

| Кадр | Разница | Порог (2 * std) | Объект переднего плана? |
|------|---------|-----------------|-------------------------|
| 1    | 0       | 1.138           | Нет                     |
| 2    | 1.8     | 1.138           | Да                      |
| 3    | 0.72    | 1.128           | Нет                     |
| 4    | 4.25    | 2.914           | Да                      |
| 5    | 8.32    | 5.668           | Да                      |

---

### **4. Полный код с комментариями**

```python
import cv2
import numpy as np

# Параметры
alpha = 0.1  # Скорость обновления фона

# Инициализация переменных
background_avg = None
background_std = None

# Захват видеопоследовательности
cap = cv2.VideoCapture("video.mp4")

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # Преобразование в градации серого
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Инициализация фона и стандартного отклонения
    if background_avg is None:
        background_avg = gray_frame.astype("float")
        background_std = np.zeros_like(gray_frame, dtype="float")

    # Обновление среднего значения фона
    cv2.accumulateWeighted(gray_frame, background_avg, alpha)

    # Обновление стандартного отклонения
    cv2.accumulateWeighted((gray_frame - background_avg) ** 2, background_std, alpha)

    # Вычисление стандартного отклонения
    std = cv2.sqrt(background_std)

    # Вычисление разницы между текущим кадром и фоном
    diff = cv2.absdiff(gray_frame, background_avg.astype("uint8"))

    # Пороговая обработка на основе стандартного отклонения
    mean_std = np.mean(std)
    _, fg_mask = cv2.threshold(diff, 2 * mean_std, 255, cv2.THRESH_BINARY)

    # Отображение результата
    cv2.imshow("Original", gray_frame)
    cv2.imshow("Foreground Mask", fg_mask)

    if cv2.waitKey(30) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```

---

### **5. Преимущества и недостатки**

#### **Преимущества**:
- Простота реализации.
- Низкая вычислительная сложность.
- Хорошо работает для статичных фонов.

#### **Недостатки**:
- Плохо адаптируется к быстрым изменениям фона (например, изменение освещения).
- Не подходит для динамических фонов (например, качающиеся деревья).

---

### **6. Заключение**
Метод усреднения фона — это мощный инструмент для выделения объектов переднего плана. Он основан на накоплении среднего значения и стандартного отклонения фона, что делает его устойчивым к шумам и медленным изменениям освещения. В коде мы используем функции OpenCV, такие как `cv2.accumulateWeighted`, `cv2.absdiff` и `cv2.threshold`, чтобы реализовать этот метод.
